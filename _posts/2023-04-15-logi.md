---
title:  "로지스틱스 회귀 연습"
excerpt: "로지스틱스 회귀에 대해서 연습해보자"

categories:
  - Blog
tags:
  - [Blog, practice, Github, Git]

toc: true
toc_sticky: true
 
date: 2023-04-14
last_modified_at: 2023-04-14

---

## 로지스틱스 회귀 연습

[kaggle 링크](https://www.kaggle.com/code/prashant111/logistic-regression-classifier-tutorial#Logistic-Regression-Classifier-Tutorial-with-Python)를 토대로 연습해보자

이 연습에서는 호주에 비가 오는지 여부를 예측하기 위해 로지스틱회귀를 이용해 이진분류 모델을 훈련한다

---


## 목차
[1. 로지스틱스 회귀 설명](#로지스틱스-회귀-설명)

[2. 로지스틱스 회귀의 직관](#2-2-로지스틱스-회귀의-직관)

[3. 로지스틱스 회귀의 가정](#3-로지스틱스-회귀의-가정)

[4. 로지스티스 회귀의 종류](#4-로지스티스-회귀의-종류)

[5. 라이브러리 불러오기](#5-라이브러리-불러오기)

[6. 데이터셋 불러오기](#6-데이터셋-불러오기)

[7. 데이터 분석 확인](#7-데이터-분석-확인)

[8. 특징 벡터 대상 변수 선언](#8-특징-벡터-대상-변수-선언)

[9. 데이터를 학습과 테스트 셋으로 분할](#9-데이터를-학습과-테스트-셋으로-분할)

[10. 특성 처리](#10-특성-처리)

[11. 특성 스케일링](#11-특성-스케일링)

[12. 모델 학습](#12-모델-학습)

[13. 결과 예측](#13-결과-예측)

[14. 정확한 점수 예측](#14-정확한-점수-예측)

[15. 혼돈 매트릭스](#15-혼돈-매트릭스)

[16. 분류 지표](#16-분류-지표)

[17. 임계값 조정](#17-임계값-조정)

[18. ROC-AUC](#18-roc-auc)



---
# 1.로지스틱스 회귀 설명

로지스틱 회귀는 데이터 분류에 있어서 가장 기본적인 알고리즘이다.

로지스틱 회귀는 지도학습 분류 알고리즘으로 관측값을 불연속적인 클래스 집합으로 예측하는데 사용된다.

따라서 결과 역시 불연속적이다.

로지스틱 회귀는 분류 문제를 가장 간단하게 해결하게 해주고 다양한 용도로 사용가능하다.

---
## 2.로지스틱스 회귀의 직관

통계학에서 로지스틱 회귀 모델은 분류목적으로 자주 사용된다.

일련의 관측값이 주어지면 로지스틱 회귀 모델을 통해 

관측값을 두 개 이상의 불연속적인 클래스로 분류하는데 도움이 된다.

따라서 대상은 본질적으로 이산형이다.

로지스틱 회귀 알고리즘은 다음과 같이 작동한다.

### 선형 방정식 구현

로지스틱 회귀 알고리즘은 독립 변수 또는 설명 변수로 선형 방정식을 구현하여 응답 값을 예측한다.

예를 들어 공부한 시간과 시험 합격 확률의 예를 살펴 보면, 공부 시간을 변수로 x1이라 하고

시험에 합격할 확률은 응답 또는 목표 변수이며 Z로 표시 된다.

하나의 설명 변수와 결과 변수가 있다면 선형 방정식은 다음과 같은 방정식으로 표현 된다.

```
z = b0 + b1x1
```
여기서 계수 b0, b1은 모델의 매개 변수이다.

변수가 여러개라면 더 확장이된다.

```
z = b0 + b1x1+ b2x2+, ... ,+ bnxn
```
이번에는 b0, b1, b2, .... bn이 모델의 매개 변수이다.

따라서 예측값은 위의 방정식으로 주어진다

### 시그모이드 함수

다음으로는 Z로 표시되는 예측 응답 값을 0과 1사이의 확률 값으로 변환 한다.

그런 다음 이 시그모이드 함수를 이용하여 모든 실제 값을 0과 1사이의 확률 값으로 적용시킨다.


머신 러닝에서 시그모이드 함수는 예측을 확률에 적용하는 데 사용된다.

시그모이드 함수는 S자의 곡선을 가지고 있어 시그모이드 곡선이라고 부르기도 한다.



시그모이드 함수는 로지스틱 함수의 특수한 경우로 다음과 같은 수학 공식으로 표현된다.

$$
Φ(z) = {\frac{1}{1 + e^{-z}}}
$$



그래프로 표현하면 다음과 같다

<img src ="https://miro.medium.com/v2/resize:fit:970/1*Xu7B5y9gp0iL5ooBj7LtWw.png">

### 의사 결정 경계

시그모이드 함수는 0과 1사이의 확률 값의 반환한다.

이 확률 값은 0또는 1인 불연속적인 클래스에 적용된다.

이 확률 값을 불연속적인 클래스(ex 예/아니오)에 적용하기 위해, 임계값을 선택한다.

이 임계값을 의사 결정 경계라고 하며 초과시 확률을 클래스 1에 적용하고  이하라면 클래스 0에 적용한다.


수학적으로는 다음과 같다

```
p≥ 0.5 -> 클래스 = 1

p < 0.5 -> 클래스 = 0

```

일반적으로 의사 결정 경계는 0.5로 설정되는데

따라서 확률값이 0.8일경우 0.5보다 크기때문에 1에 적용된다.

반대로 0.2인 경우 0.5보다 작기 때문에 에 적용된다.

그래프로 표현하면 다음과 같다.

<img src ="https://ml-cheatsheet.readthedocs.io/en/latest/_images/logistic_regression_sigmoid_w_threshold.png">

예측 만들기

이제, 로지스틱 회귀에서 시그모이드 함수와 결정경계에 대해 알게 되었다.

이 두가지를 이용하여 예측 함수를 작성 할 수 있다.

로지스틱 회귀의 예측 함수는 양수일때 참을 반환하고 이를 클래스 1 P(class = 1)이라고 한다.

1에 가까우면 클래스 1에 속하고 그렇지 않으면 클래스 0에 속한다.


---
## 3.로지스틱스 회귀의 가정

로지스틱 회귀 모델에는 몇가지 가정이 필요하다.

1. 로지스틱 회귀 모델은 종속 변수가 이진, 다항식 또는 서수여야 한다.

2. 관측값이 서로 독립적이어야 한다. 따라서 관측값이 반복된 측정값에서 나온것이 아니여야 한다.

3. 독립 변수간에 가중 공선성이 전혀 필요하지 않다. 독립 변수 사이에 높은 상관 관계가 없어야 하기 때문이다.

4. 로지스틱 회귀 모델은 독립 변수와 로그 확률의 선형성을 가진다.

5. 로지스틱 회귀 모델의 성공 여부는 표본 크기에 따라 달라지는데 큰 표본 크기가 유리하다.


---
## 4.로지스티스 회귀의 종류

로지스틱스 회귀 모델은 여러개로 분류할수 있는데, 이는 타겟의 범주에 따라 3가지로 분류 가능하다.

1. 이진 로지스틱스 회귀

이진 로지스틱스 회귀에서는 대상 변수의 범주가 두가지인 경우이다. 

2. 다항 로지스틱스 회귀

다항 로지스틱스 회귀는 대상 변수가 특정 순서가 아닌 세 개 이상의 범주가 있는 경우이다.

3 서수 로지스틱스 회귀

서수 로지스틱스 회귀에는 세 개이상의 서수 범주가 있는 경우로 범주에 내재적인 순서가 존재한다.

---
## 5.라이브러리 불러오기

파이썬 3 환경에는 유용한 분석 라이브러리가 많이 설치되어 있는데

예를 들면 다음과 같은 패키지가 존재한다.

```python
import numpy as np # linear algebra
import pandas as pd # data processing, CSV file I/O (e.g. pd.read_csv)
import matplotlib.pyplot as plt # data visualization
import seaborn as sns # statistical data visualization
%matplotlib inline
```

입력 데이터 파일은 "../input/" 디렉토리에서 사용할 수 있다.

```python
import os
for dirname, _, filenames in os.walk('/kaggle/input'):
    for filename in filenames:
        print(os.path.join(dirname, filename))        
```
>/input/weather-dataset-rattle-package/weatherAUS.csv

---
## 6.데이터셋 불러오기

```
data = '/kaggle/input/weather-dataset-rattle-package/weatherAUS.csv'

df = pd.read_csv(data)
```

---
## 7.데이터 분석 확인
다음으로 데이터를 탐색하여 데이터에 대한 이해도를 확보한다.

```python
df.shape
```
>(142193, 24)


```
df.head()
```


|Date|Location|MinTem|MaxTemp|Rainfall|Evaporation|Sunshine|WindGustDir|WindGustSpeed|WindDir9am|...|Humidity3pm|Pressure9am|Pressure3pm|Cloud9am|Cloud3pm|Temp9am|Temp3pm|RainToday|RISK_MM|RainTomorrow|
|:---|:---|:---|:---|:---|:---|:---|:---|:---|:---|:---|:---|:---|:---|:---|:---|:---|:---|:---|:---|:---|
|2008-12-01|Albury|13.4|22.9|0.6|NaN|NaN|W|44.0|W|...|22.0|1007.7|1007.1|8.0|NaN|16.9|21.8|No|0.0|No|
|2008-12-02|Albury|7.4|25.1|0.0|NaN|NaN|WNW|44.0|NNW|...|25.0|1010.6|1007.8|NaN|NaN|17.2|24.3|No|0.0|No|
|2008-12-03|Albury|12.9|25.7|0.0|NaN|NaN|WSW|46.0|W|...|30.0|1007.6|1008.7|NaN|2.0|21.0|23.2|No|0.0|No|
|2008-12-04|Albury|9.2|28.0|0.0|NaN|NaN|NE|24.0|SE|...|16.0|1017.6|1012.8|NaN|NaN|18.1|26.5|No|1.0|No|
|2008-12-05|Albury|17.5|32.3|1.0|NaN|NaN|W|41.0|ENE|...|33.0|1010.8|1006.0|7.0|8.0|17.8|29.7|No|0.2|No|


```python
col_names = df.columns

col_names
```

>Index(['Date', 'Location', 'MinTemp', 'MaxTemp', 'Rainfall', 'Evaporation',
       'Sunshine', 'WindGustDir', 'WindGustSpeed', 'WindDir9am', 'WindDir3pm',
       'WindSpeed9am', 'WindSpeed3pm', 'Humidity9am', 'Humidity3pm',
       'Pressure9am', 'Pressure3pm', 'Cloud9am', 'Cloud3pm', 'Temp9am',
       'Temp3pm', 'RainToday', 'RISK_MM', 'RainTomorrow'],
      dtype='object')
```python
col_names = df.columns

col_names
```

>Index(['Date', 'Location', 'MinTemp', 'MaxTemp', 'Rainfall', 'Evaporation',
       'Sunshine', 'WindGustDir', 'WindGustSpeed', 'WindDir9am', 'WindDir3pm',
       'WindSpeed9am', 'WindSpeed3pm', 'Humidity9am', 'Humidity3pm',
       'Pressure9am', 'Pressure3pm', 'Cloud9am', 'Cloud3pm', 'Temp9am',
       'Temp3pm', 'RainToday', 'RISK_MM', 'RainTomorrow'],
      dtype='object')
      
### RISK MM 특징 삭제
데이터 세트에서 RISK_MM 특징을 삭제해야 한다고 데이터 세트 설명에 존재한다, 따라서 삭제해주도록 한다.

```python
df.drop(['RISK_MM'], axis=1, inplace=True)
df.info()
```

><class 'pandas.core.frame.DataFrame'>
>
>RangeIndex: 142193 entries, 0 to 142192
>
>Data columns (total 23 columns):
>
>Date             142193 non-null object
>
>Location         142193 non-null object
>
>MinTemp          141556 non-null float64
>
>MaxTemp          141871 non-null float64
>
>Rainfall         140787 non-null float64
>
>Evaporation      81350 non-null float64
>
>Sunshine         74377 non-null float64
>
>WindGustDir      132863 non-null object
>
>WindGustSpeed    132923 non-null float64
>
>WindDir9am       132180 non-null object
>
>WindDir3pm       138415 non-null object
>
>WindSpeed9am     140845 non-null float6
>
>WindSpeed3pm     139563 non-null float64
>
>Humidity9am      140419 non-null float64
>
>Humidity3pm      138583 non-null float64
>
>Pressure9am      128179 non-null float64
>
>Pressure3pm      128212 non-null float64
>
>Cloud9am         88536 non-null float64
>
>Cloud3pm         85099 non-null float64
>
>Temp9am          141289 non-null float64
>
>Temp3pm          139467 non-null float64
>
>RainToday        140787 non-null object
>
>RainTomorrow     142193 non-null object
>
>dtypes: float64(16), object(7)
>
>memory usage: 25.0+ MB

### 변수의 유형

```ptython
categorical = [var for var in df.columns if df[var].dtype=='O']

print('There are {} categorical variables\n'.format(len(categorical)))

print('The categorical variables are :', categorical)

```
>There are 7 categorical variables
>
>The categorical variables are : ['Date', 'Location', 'WindGustDir', 'WindDir9am', 'WindDir3pm', 'RainToday', 'RainTomorrow']

다시 head()로 확인

```python
df[categorical].head()
```


|Date|Location|WindGustDir|WindDir9am|WindDir3pm|RainToday|RainTomorrow|
|:---|:---|:---|:---|:---|:---|:---|
|2008-12-01|Albury|W|W|WNW|No|No|
|2008-12-02|Albury|WNW|NNW|WNW|No|No|
|2008-12-03|Albury|WSW|W|WNW|No|No|
|2008-12-04|Albury|NE|SE|WNW|No|No|
|2008-12-05|Albury|W|ENE|WNW|No|No|



### 범주형 변수를 요약하면 다음과 같다

 * 날짜 변수 - Date
 * 6개의 범주형 변수 - Location, WindGustDir, WindDir9am, WindDir3pm, RainToday, RainTomorrow
 * 이진 범주형 변수- RainToday, RainTomorrow
 * 대상 변수 - RainTomorrow


### 범주현 변수의 문제 탐색

결측치를 찾아준다.
```python
df[categorical].isnull().sum()
```
>Date                0
>
>Location            0
>
>WindGustDir      9330
>
>WindDir9am      10013
>
>WindDir3pm       3778
>
>RainToday        1406
>
>RainTomorrow        0
>
>dtype: int64

결측치가 포함된 범주형 변수만 프린트한다.
```python
cat1 = [var for var in categorical if df[var].isnull().sum()!=0]
print(df[cat1].isnull().sum())
```
>WindGustDir     9330
>
>WindDir9am     10013
>
>WindDir3pm      3778
>
>RainToday       1406
>
>dtype: int64

4개의 범주형 변수만이 결측치가 존재함을 확인했다.

WindGustDir, WindDir9am, WindDir3pm, RainToday 에 결측치가 존재한다.

### 범주형 변수의 빈도 수

다음으로 범주형 변수의 빈도 수를 확인한다.
```python
for var in categorical: 
    
    print(df[var].value_counts())
```
```
2014-04-15    49
2013-08-04    49
2014-03-18    49
2014-07-08    49
2014-02-27    49
              ..
2007-11-01     1
2007-12-30     1
2007-12-12     1
2008-01-20     1
2007-12-05     1
Name: Date, Length: 3436, dtype: int64
Canberra            3418
Sydney              3337
Perth               3193
Darwin              3192
Hobart              3188
Brisbane            3161
Adelaide            3090
Bendigo             3034
Townsville          3033
AliceSprings        3031
MountGambier        3030
Ballarat            3028
Launceston          3028
Albany              3016
Albury              3011
PerthAirport        3009
MelbourneAirport    3009
Mildura             3007
SydneyAirport       3005
Nuriootpa           3002
Sale                3000
Watsonia            2999
Tuggeranong         2998
Portland            2996
Woomera             2990
Cobar               2988
Cairns              2988
Wollongong          2983
GoldCoast           2980
WaggaWagga          2976
NorfolkIsland       2964
Penrith             2964
SalmonGums          2955
Newcastle           2955
CoffsHarbour        2953
Witchcliffe         2952
Richmond            2951
Dartmoor            2943
NorahHead           2929
BadgerysCreek       2928
MountGinini         2907
Moree               2854
Walpole             2819
PearceRAAF          2762
Williamtown         2553
Melbourne           2435
Nhil                1569
Katherine           1559
Uluru               1521
Name: Location, dtype: int64
W      9780
SE     9309
E      9071
N      9033
SSE    8993
S      8949
WSW    8901
SW     8797
SSW    8610
WNW    8066
NW     8003
ENE    7992
ESE    7305
NE     7060
NNW    6561
NNE    6433
Name: WindGustDir, dtype: int64
N      11393
SE      9162
E       9024
SSE     8966
NW      8552
S       8493
W       8260
SW      8237
NNE     7948
NNW     7840
ENE     7735
ESE     7558
NE      7527
SSW     7448
WNW     7194
WSW     6843
Name: WindDir9am, dtype: int64
SE     10663
W       9911
S       9598
WSW     9329
SW      9182
SSE     9142
N       8667
WNW     8656
NW      8468
ESE     8382
E       8342
NE      8164
SSW     8010
NNW     7733
ENE     7724
NNE     6444
Name: WindDir3pm, dtype: int64
No     109332
Yes     31455
Name: RainToday, dtype: int64
No     110316
Yes     31877
Name: RainTomorrow, dtype: int64
```
```python
for var in categorical: 
    
    print(df[var].value_counts()/np.float(len(df)))
```
범주형 변수의 빈도 분포 확인
```
2014-04-15    0.000345
2013-08-04    0.000345
2014-03-18    0.000345
2014-07-08    0.000345
2014-02-27    0.000345
                ...   
2007-11-01    0.000007
2007-12-30    0.000007
2007-12-12    0.000007
2008-01-20    0.000007
2007-12-05    0.000007
Name: Date, Length: 3436, dtype: float64
Canberra            0.024038
Sydney              0.023468
Perth               0.022455
Darwin              0.022448
Hobart              0.022420
Brisbane            0.022230
Adelaide            0.021731
Bendigo             0.021337
Townsville          0.021330
AliceSprings        0.021316
MountGambier        0.021309
Ballarat            0.021295
Launceston          0.021295
Albany              0.021211
Albury              0.021175
PerthAirport        0.021161
MelbourneAirport    0.021161
Mildura             0.021147
SydneyAirport       0.021133
Nuriootpa           0.021112
Sale                0.021098
Watsonia            0.021091
Tuggeranong         0.021084
Portland            0.021070
Woomera             0.021028
Cobar               0.021014
Cairns              0.021014
Wollongong          0.020979
GoldCoast           0.020957
WaggaWagga          0.020929
NorfolkIsland       0.020845
Penrith             0.020845
SalmonGums          0.020782
Newcastle           0.020782
CoffsHarbour        0.020768
Witchcliffe         0.020761
Richmond            0.020753
Dartmoor            0.020697
NorahHead           0.020599
BadgerysCreek       0.020592
MountGinini         0.020444
Moree               0.020071
Walpole             0.019825
PearceRAAF          0.019424
Williamtown         0.017954
Melbourne           0.017125
Nhil                0.011034
Katherine           0.010964
Uluru               0.010697
Name: Location, dtype: float64
W      0.068780
SE     0.065467
E      0.063794
N      0.063526
SSE    0.063245
S      0.062936
WSW    0.062598
SW     0.061867
SSW    0.060552
WNW    0.056726
NW     0.056283
ENE    0.056205
ESE    0.051374
NE     0.049651
NNW    0.046142
NNE    0.045241
Name: WindGustDir, dtype: float64
N      0.080123
SE     0.064434
E      0.063463
SSE    0.063055
NW     0.060144
S      0.059729
W      0.058090
SW     0.057928
NNE    0.055896
NNW    0.055136
ENE    0.054398
ESE    0.053153
NE     0.052935
SSW    0.052380
WNW    0.050593
WSW    0.048125
Name: WindDir9am, dtype: float64
SE     0.074990
W      0.069701
S      0.067500
WSW    0.065608
SW     0.064574
SSE    0.064293
N      0.060952
WNW    0.060875
NW     0.059553
ESE    0.058948
E      0.058667
NE     0.057415
SSW    0.056332
NNW    0.054384
ENE    0.054321
NNE    0.045319
Name: WindDir3pm, dtype: float64
No     0.768899
Yes    0.221213
Name: RainToday, dtype: float64
No     0.775819
Yes    0.224181
Name: RainTomorrow, dtype: float64
```
### 레이블 수 : 카디널리티
범주형 변수내의 레이블 수를 카디널리티라고 한다

변수내의 레이블 수가 많으면 높은 카디널리티라고 하는데

이는 머신 러닝 모델에서 문제를 일으킬 수 있기 때문에 한번 확인해본다.

```python
for var in categorical:
    
    print(var, ' contains ', len(df[var].unique()), ' labels')
```
```
Date  contains  3436  labels
Location  contains  49  labels
WindGustDir  contains  17  labels
WindDir9am  contains  17  labels
WindDir3pm  contains  17  labels
RainToday  contains  3  labels
RainTomorrow  contains  2  labels
```

Date에 변수가 많아, 전처리가 필요함을 알 수 있다



### 날짜 변수의 특성 전처리

```
df['Date'].dtypes
```
> dtype('O')

Date의 타입이 오브젝트임을 확인했다.

Date를 날짜와 시간 형식으로 구문을 분석한다

```python
df['Date'] = pd.to_datetime(df['Date'])
```

해를 먼저 추출

```python
df['Year'] = df['Date'].dt.year
df['Year'].head()
```
```
0    2008
1    2008
2    2008
3    2008
4    2008
Name: Year, dtype: int64
```
다음으로는 월을 추출한다

```python
df['Month'] = df['Date'].dt.month

df['Month'].head()
```
```
0    12
1    12
2    12
3    12
4    12
Name: Month, dtype: int64
```

마지막으로 일을 추출해준다
```python
f['Day'] = df['Date'].dt.day

df['Day'].head()
```

```
0    1
1    2
2    3
3    4
4    5
Name: Day, dtype: int64
```

다시 데이터 셋의 요약을 확인한다
```python
df.info()
```

```
<class 'pandas.core.frame.DataFrame'>
RangeIndex: 142193 entries, 0 to 142192
Data columns (total 26 columns):
Date             142193 non-null datetime64[ns]
Location         142193 non-null object
MinTemp          141556 non-null float64
MaxTemp          141871 non-null float64
Rainfall         140787 non-null float64
Evaporation      81350 non-null float64
Sunshine         74377 non-null float64
WindGustDir      132863 non-null object
WindGustSpeed    132923 non-null float64
WindDir9am       132180 non-null object
WindDir3pm       138415 non-null object
WindSpeed9am     140845 non-null float64
WindSpeed3pm     139563 non-null float64
Humidity9am      140419 non-null float64
Humidity3pm      138583 non-null float64
Pressure9am      128179 non-null float64
Pressure3pm      128212 non-null float64
Cloud9am         88536 non-null float64
Cloud3pm         85099 non-null float64
Temp9am          141289 non-null float64
Temp3pm          139467 non-null float64
RainToday        140787 non-null object
RainTomorrow     142193 non-null object
Year             142193 non-null int64
Month            142193 non-null int64
Day              142193 non-null int64
dtypes: datetime64[ns](1), float64(16), int64(3), object(6)
memory usage: 28.2+ MB
```
Date 변수로부터 세개의 열이 추가된것을 알 수 있다.

이제 원래 Date를 삭제해준다.

```python
df.drop('Date', axis=1, inplace = True)
```

```python
df.head()
```


|Location|MinTemp|MaxTemp|Rainfall|Evaporation|Sunshine|WindGustDir|WindGustSpeed|WindDir9am|WindDir3pm|...|Pressure3pm|Cloud9am|Cloud3pm|Temp9am|Temp3pm|RainToday|RainTomorrow|Year|Month|Day|
|:---|:---|:---|:---|:---|:---|:---|:---|:---|:---|:---|:---|:---|:---|:---|:---|:---|:---|:---|:---|:---|
|Albury|13.4|22.9|0.6|NaN|NaN|W|44.0|W|WNW|...|1007.1|8.0|NaN|16.9|21.8|No|No|2008|12|1|
|Albury|7.4|25.1|0.0|NaN|NaN|WNW|44.0|NNW|WsW|...|1007.2|NaN|NaN|17.2|24.3|No|No|2008|12|2|
|Albury|12.9|25.7|0.0|NaN|NaN|WSW|46.0|W|WsW|...|1008.7|NaN|2.0|21.0|23.2|No|No|2008|12|3|
|Albury|9.2|28|0.0|NaN|NaN|NE|24.0|SE|E|...|1012.8|NaN|NaN|18.1|26.5|No|No|2008|12|4|
|Albury|17.5|32.3|0.0|NaN|NaN|W|41.0|EBE|NW|...|1006.0|7.0|8.0|17.8|29.7|No|No|2008|12|5|



Date가 삭제되고 연,월,일이 추가된것을 확인할 수 있다.

### 범주형 변수 탐색

이번에는 각각의 범주형 변수를 한개씩 살펴본다
```python

categorical = [var for var in df.columns if df[var].dtype=='O']

print('There are {} categorical variables\n'.format(len(categorical)))

print('The categorical variables are :', categorical)
```
```
There are 6 categorical variables

The categorical variables are : ['Location', 'WindGustDir', 'WindDir9am', 'WindDir3pm', 'RainToday', 'RainTomorrow']
```
데이터 셋에 6개의 범주형 변수가 있음을 확인할 수 있다.

이제 범주현 변수의 결측치를 확인한다.

```python
df[categorical].isnull().sum()
```
```
Location            0
WindGustDir      9330
WindDir9am      10013
WindDir3pm       3778
RainToday        1406
RainTomorrow        0
dtype: int64
```

WindGustDir, WindDir9am, WindDir3pm, RainToday 이 변수들에 결측치가 존재함을 확인할수 있다.

### Location 탐색하기

```python
print('Location contains', len(df.Location.unique()), 'labels')
```
>Location contains 49 labels

```python
df.Location.unique()
```

```
array(['Albury', 'BadgerysCreek', 'Cobar', 'CoffsHarbour', 'Moree',
       'Newcastle', 'NorahHead', 'NorfolkIsland', 'Penrith', 'Richmond',
       'Sydney', 'SydneyAirport', 'WaggaWagga', 'Williamtown',
       'Wollongong', 'Canberra', 'Tuggeranong', 'MountGinini', 'Ballarat',
       'Bendigo', 'Sale', 'MelbourneAirport', 'Melbourne', 'Mildura',
       'Nhil', 'Portland', 'Watsonia', 'Dartmoor', 'Brisbane', 'Cairns',
       'GoldCoast', 'Townsville', 'Adelaide', 'MountGambier', 'Nuriootpa',
       'Woomera', 'Albany', 'Witchcliffe', 'PearceRAAF', 'PerthAirport',
       'Perth', 'SalmonGums', 'Walpole', 'Hobart', 'Launceston',
       'AliceSprings', 'Darwin', 'Katherine', 'Uluru'], dtype=object)
```
이번에는 Locarion의 값의 분포를 확인한다

```python
df.Location.value_counts()
```
```
Canberra            3418
Sydney              3337
Perth               3193
Darwin              3192
Hobart              3188
Brisbane            3161
Adelaide            3090
Bendigo             3034
Townsville          3033
AliceSprings        3031
MountGambier        3030
Ballarat            3028
Launceston          3028
Albany              3016
Albury              3011
PerthAirport        3009
MelbourneAirport    3009
Mildura             3007
SydneyAirport       3005
Nuriootpa           3002
Sale                3000
Watsonia            2999
Tuggeranong         2998
Portland            2996
Woomera             2990
Cobar               2988
Cairns              2988
Wollongong          2983
GoldCoast           2980
WaggaWagga          2976
NorfolkIsland       2964
Penrith             2964
SalmonGums          2955
Newcastle           2955
CoffsHarbour        2953
Witchcliffe         2952
Richmond            2951
Dartmoor            2943
NorahHead           2929
BadgerysCreek       2928
MountGinini         2907
Moree               2854
Walpole             2819
PearceRAAF          2762
Williamtown         2553
Melbourne           2435
Nhil                1569
Katherine           1559
Uluru               1521
Name: Location, dtype: int64
```
이제는 원-핫 인코딩을 통해 Location을 전처리 해준다
```python
pd.get_dummies(df.Location, drop_first=True).head()
```


 	
  
  |Albany|Albury|AliceSprings|BadgerysCreek|Ballarat|Bendigo|Brisbane|Cairns|Canberra|Cobar|...|Townsville|Tuggeranong|Uluru|WaggaWagga|Walpole|Watsonia|Williamtown|Witchcliffe|Wollongong|Woomera|
|---:|---:|---:|---:|---:|---:|---:|---:|---:|---:|---:|---:|---:|---:|---:|---:|---:|---:|---:|---:|---:|
|0|1|0|0|0|0|0|0|0|0|...|0|0|0|0|0|0|0|0|0|0|
|0|1|0|0|0|0|0|0|0|0|...|0|0|0|0|0|0|0|0|0|0|
|0|1|0|0|0|0|0|0|0|0|...|0|0|0|0|0|0|0|0|0|0|
|0|1|0|0|0|0|0|0|0|0|...|0|0|0|0|0|0|0|0|0|0|
|0|1|0|0|0|0|0|0|0|0|...|0|0|0|0|0|0|0|0|0|0|

### WIndGustDir 탐색하기

WindGustDir의 레이블을 탐색한다

```python
print('WindGustDir contains', len(df['WindGustDir'].unique()), 'labels')
```
>WindGustDir contains 17 labels

```python
df['WindGustDir'].unique()
```
```
array(['W', 'WNW', 'WSW', 'NE', 'NNW', 'N', 'NNE', 'SW', 'ENE', 'SSE',
       'S', 'NW', 'SE', 'ESE', nan, 'E', 'SSW'], dtype=object)
```

```python
df.WindGustDir.value_counts()
```
```
W      9780
SE     9309
E      9071
N      9033
SSE    8993
S      8949
WSW    8901
SW     8797
SSW    8610
WNW    8066
NW     8003
ENE    7992
ESE    7305
NE     7060
NNW    6561
NNE    6433
Name: WindGustDir, dtype: int64
```
또 원핫 인코딩 해준다
```python
pd.get_dummies(df.WindGustDir, drop_first=True, dummy_na=True)
```

```python
pd.get_dummies(df.WindGustDir, drop_first=True, dummy_na=True).sum(axis=0)
```
```
ENE    7992
ESE    7305
N      9033
NE     7060
NNE    6433
NNW    6561
NW     8003
S      8949
SE     9309
SSE    8993
SSW    8610
SW     8797
W      9780
WNW    8066
WSW    8901
NaN    9330
dtype: int64
```

### WindDir9am 탐색하기
```python
print('WindDir9am contains', len(df['WindDir9am'].unique()), 'labels')
```
>WindDir9am contains 17 labels

unique로 확인.

```python
df['WindDir9am'].unique()
```
```
array(['W', 'NNW', 'SE', 'ENE', 'SW', 'SSE', 'S', 'NE', nan, 'SSW', 'N',
       'WSW', 'ESE', 'E', 'NW', 'WNW', 'NNE'], dtype=object)
```
이제는 값을 확인해준다.

```python
df['WindDir9am'].value_counts()
```
```
N      11393
SE      9162
E       9024
SSE     8966
NW      8552
S       8493
W       8260
SW      8237
NNE     7948
NNW     7840
ENE     7735
ESE     7558
NE      7527
SSW     7448
WNW     7194
WSW     6843
Name: WindDir9am, dtype: int64
```
역시 원 핫 인코딩
```python
pd.get_dummies(df.WindDir9am, drop_first=True, dummy_na=True)
```
```python
pd.get_dummies(df.WindDir9am, drop_first=True, dummy_na=True).sum(axis=0)
```
```
ENE     7735
ESE     7558
N      11393
NE      7527
NNE     7948
NNW     7840
NW      8552
S       8493
SE      9162
SSE     8966
SSW     7448
SW      8237
W       8260
WNW     7194
WSW     6843
NaN    10013
dtype: int64
```

10013개의 결측치가 있는것도 확인했다.

이외에 다른 변수들도 원-핫 인코딩 해준다

### WindDir3pm

```python
pd.get_dummies(df.WindDir3pm, drop_first=True, dummy_na=True).sum(axis=0)
```
```
ENE     7724
ESE     8382
N       8667
NE      8164
NNE     6444
NNW     7733
NW      8468
S       9598
SE     10663
SSE     9142
SSW     8010
SW      9182
W       9911
WNW     8656
WSW     9329
NaN     3778
dtype: int64
```

### RainToday
```python
pd.get_dummies(df.RainToday, drop_first=True, dummy_na=True).sum(axis=0)
```
```
Yes    31455
NaN     1406
dtype: int64
```
### 수치형 데이터를 탐색

이번에는 수치형 데이터들을 탐색해준다

```python

numerical = [var for var in df.columns if df[var].dtype!='O']

print('There are {} numerical variables\n'.format(len(numerical)))

print('The numerical variables are :', numerical)
```
```
There are 19 numerical variables

The numerical variables are : ['MinTemp', 'MaxTemp', 'Rainfall', 'Evaporation', 'Sunshine', 'WindGustSpeed', 'WindSpeed9am', 'WindSpeed3pm', 'Humidity9am', 'Humidity3pm', 'Pressure9am', 'Pressure3pm', 'Cloud9am', 'Cloud3pm', 'Temp9am', 'Temp3pm', 'Year', 'Month', 'Day']
```
```python
df[numerical].head()
```


<div>

<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>MinTemp</th>
      <th>MaxTemp</th>
      <th>Rainfall</th>
      <th>Evaporation</th>
      <th>Sunshine</th>
      <th>WindGustSpeed</th>
      <th>WindSpeed9am</th>
      <th>WindSpeed3pm</th>
      <th>Humidity9am</th>
      <th>Humidity3pm</th>
      <th>Pressure9am</th>
      <th>Pressure3pm</th>
      <th>Cloud9am</th>
      <th>Cloud3pm</th>
      <th>Temp9am</th>
      <th>Temp3pm</th>
      <th>Year</th>
      <th>Month</th>
      <th>Day</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>13.4</td>
      <td>22.9</td>
      <td>0.6</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>44.0</td>
      <td>20.0</td>
      <td>24.0</td>
      <td>71.0</td>
      <td>22.0</td>
      <td>1007.7</td>
      <td>1007.1</td>
      <td>8.0</td>
      <td>NaN</td>
      <td>16.9</td>
      <td>21.8</td>
      <td>2008</td>
      <td>12</td>
      <td>1</td>
    </tr>
    <tr>
      <th>1</th>
      <td>7.4</td>
      <td>25.1</td>
      <td>0.0</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>44.0</td>
      <td>4.0</td>
      <td>22.0</td>
      <td>44.0</td>
      <td>25.0</td>
      <td>1010.6</td>
      <td>1007.8</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>17.2</td>
      <td>24.3</td>
      <td>2008</td>
      <td>12</td>
      <td>2</td>
    </tr>
    <tr>
      <th>2</th>
      <td>12.9</td>
      <td>25.7</td>
      <td>0.0</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>46.0</td>
      <td>19.0</td>
      <td>26.0</td>
      <td>38.0</td>
      <td>30.0</td>
      <td>1007.6</td>
      <td>1008.7</td>
      <td>NaN</td>
      <td>2.0</td>
      <td>21.0</td>
      <td>23.2</td>
      <td>2008</td>
      <td>12</td>
      <td>3</td>
    </tr>
    <tr>
      <th>3</th>
      <td>9.2</td>
      <td>28.0</td>
      <td>0.0</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>24.0</td>
      <td>11.0</td>
      <td>9.0</td>
      <td>45.0</td>
      <td>16.0</td>
      <td>1017.6</td>
      <td>1012.8</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>18.1</td>
      <td>26.5</td>
      <td>2008</td>
      <td>12</td>
      <td>4</td>
    </tr>
    <tr>
      <th>4</th>
      <td>17.5</td>
      <td>32.3</td>
      <td>1.0</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>41.0</td>
      <td>7.0</td>
      <td>20.0</td>
      <td>82.0</td>
      <td>33.0</td>
      <td>1010.8</td>
      <td>1006.0</td>
      <td>7.0</td>
      <td>8.0</td>
      <td>17.8</td>
      <td>29.7</td>
      <td>2008</td>
      <td>12</td>
      <td>5</td>
    </tr>
  </tbody>
</table>
</div>

### 수치형 변수들을 요약하면 다음과 같다
 * 16개의 수치형 변수 존재.
 * MinTemp, MaxTemp, Rainfall, Evaporation, Sunshine, WindGustSpeed, WindSpeed9am, WindSpeed3pm, Humidity9am, Humidity3pm, Pressure9am, Pressure3pm, Cloud9am, Cloud3pm, Temp9am and Temp3pm는 수치형 변수이다.
 * 모든 수치형 변수는 연속형이다.

### 수치형 변수의 문제점 확인

```python
df[numerical].isnull().sum()
```
```
MinTemp            637
MaxTemp            322
Rainfall          1406
Evaporation      60843
Sunshine         67816
WindGustSpeed     9270
WindSpeed9am      1348
WindSpeed3pm      2630
Humidity9am       1774
Humidity3pm       3610
Pressure9am      14014
Pressure3pm      13981
Cloud9am         53657
Cloud3pm         57094
Temp9am            904
Temp3pm           2726
Year                 0
Month                0
Day                  0
dtype: int64
```
모두 결측치가 존재함을 확인했다

### 수치형 변수의 이상치
```python
print(round(df[numerical].describe()),2)
```
```
        MinTemp   MaxTemp  Rainfall  Evaporation  Sunshine  WindGustSpeed  \
count  141556.0  141871.0  140787.0      81350.0   74377.0       132923.0   
mean       12.0      23.0       2.0          5.0       8.0           40.0   
std         6.0       7.0       8.0          4.0       4.0           14.0   
min        -8.0      -5.0       0.0          0.0       0.0            6.0   
25%         8.0      18.0       0.0          3.0       5.0           31.0   
50%        12.0      23.0       0.0          5.0       8.0           39.0   
75%        17.0      28.0       1.0          7.0      11.0           48.0   
max        34.0      48.0     371.0        145.0      14.0          135.0   

       WindSpeed9am  WindSpeed3pm  Humidity9am  Humidity3pm  Pressure9am  \
count      140845.0      139563.0     140419.0     138583.0     128179.0   
mean           14.0          19.0         69.0         51.0       1018.0   
std             9.0           9.0         19.0         21.0          7.0   
min             0.0           0.0          0.0          0.0        980.0   
25%             7.0          13.0         57.0         37.0       1013.0   
50%            13.0          19.0         70.0         52.0       1018.0   
75%            19.0          24.0         83.0         66.0       1022.0   
max           130.0          87.0        100.0        100.0       1041.0   

       Pressure3pm  Cloud9am  Cloud3pm   Temp9am   Temp3pm      Year  \
count     128212.0   88536.0   85099.0  141289.0  139467.0  142193.0   
mean        1015.0       4.0       5.0      17.0      22.0    2013.0   
std            7.0       3.0       3.0       6.0       7.0       3.0   
min          977.0       0.0       0.0      -7.0      -5.0    2007.0   
25%         1010.0       1.0       2.0      12.0      17.0    2011.0   
50%         1015.0       5.0       5.0      17.0      21.0    2013.0   
75%         1020.0       7.0       7.0      22.0      26.0    2015.0   
max         1040.0       9.0       9.0      40.0      47.0    2017.0   

          Month       Day  
count  142193.0  142193.0  
mean        6.0      16.0  
std         3.0       9.0  
min         1.0       1.0  
25%         3.0       8.0  
50%         6.0      16.0  
75%         9.0      23.0  
max        12.0      31.0   2
```

Rainfall, Evaporation, WindSpeed9anm WindSpeed3pm에서 최대치, 최저치차이나 평균치를 살펴보면 이상치가 포함될수 있음을 확인한다


이제는 그래프로 표현해본다

```python
plt.figure(figsize=(15,10))


plt.subplot(2, 2, 1)
fig = df.boxplot(column='Rainfall')
fig.set_title('')
fig.set_ylabel('Rainfall')


plt.subplot(2, 2, 2)
fig = df.boxplot(column='Evaporation')
fig.set_title('')
fig.set_ylabel('Evaporation')


plt.subplot(2, 2, 3)
fig = df.boxplot(column='WindSpeed9am')
fig.set_title('')
fig.set_ylabel('WindSpeed9am')


plt.subplot(2, 2, 4)
fig = df.boxplot(column='WindSpeed3pm')
fig.set_title('')
fig.set_ylabel('WindSpeed3pm')
```
```
Text(0, 0.5, 'WindSpeed3pm')
```
<img src = "https://www.kaggleusercontent.com/kf/30116378/eyJhbGciOiJkaXIiLCJlbmMiOiJBMTI4Q0JDLUhTMjU2In0..VrTZZcOzyFCPjeO278WvAg.lV--huY2KxUMOd-2v3tpIjCPqwT1S9XO3tZsxrjcaRUZ3JlxqB_XUrdKRikDHHbU8ELvoR6lDJgAlQ4koO7PgaNNqOrNKXBbzql75nDQVTlTFDBOIi-kjVcHZ8Bu_3OIrnOOErbBwWV1h_s2CEWjT8cJFV1ltPo-wxA1RqBABL7OEmleCLqFqYQ9kUEJOF9rzFu9s79UVKCw7JIzZ8wLizsSkK8OPTalgJa4YoqYyonkOwgsswJ1nlIdmkvTflVQKXBbVxsPqZ72jvmnhZJ8wcIuXUoG84GRleTC_JmL8HJI6gnTbyHBIxKUYzKQqQAy1IkG7u3qcqVnk-WkhggtRSgKziogQ9J0nEKEj0wC4abQiFpVtb5XLR1VwLIkpZmBTyfq1k_StFhK1O3j4qjvKLO2o3viUcmUEiOsCKw0-km4ERhEE6yft3RUD5Qx5-1pK79zVdbTN7hg_d-GCUxORV7MiQRbUhPblA1_HUvGhCbN58M-C9tqq9Qv4QX8bnRidH8CwJxLeqeJQNr5iqfQs1goRUgBIGd0G539aW5PlnB_v2X4YUpwHq1i8uwKqrq7uvlcGv9GYSoeBL_UvoLddjJYzIKQjipuojnq3aTId2tl9MK2Zlwu0cdH1Q0uu88N_-8VAYiT3x55fsiwK2Mno_hopJJiL8hPxc-JWArn83BEiLVid7Pj53da8qDYrQ9q.VwOMT8yKYZBcOrP5WZCO9g/__results___files/__results___100_1.png">

해당 변수에 이상치가 많음을 도표로 확인할 수 있다.

### 변수 분포 확인

이번에는 히스토그램을 통해 분포를 확인한다.

이를 통해 분포가 정상적인지 확인하고 정규분포인 경우 극값분석을 수행하며 반대로 왜곡된 경우에는 사분위수 범위를 찾는다


```python
plt.figure(figsize=(15,10))


plt.subplot(2, 2, 1)
fig = df.Rainfall.hist(bins=10)
fig.set_xlabel('Rainfall')
fig.set_ylabel('RainTomorrow')


plt.subplot(2, 2, 2)
fig = df.Evaporation.hist(bins=10)
fig.set_xlabel('Evaporation')
fig.set_ylabel('RainTomorrow')


plt.subplot(2, 2, 3)
fig = df.WindSpeed9am.hist(bins=10)
fig.set_xlabel('WindSpeed9am')
fig.set_ylabel('RainTomorrow')


plt.subplot(2, 2, 4)
fig = df.WindSpeed3pm.hist(bins=10)
fig.set_xlabel('WindSpeed3pm')
fig.set_ylabel('RainTomorrow')
```
```
Text(0, 0.5, 'RainTomorrow')
```

<img src = "https://www.kaggleusercontent.com/kf/30116378/eyJhbGciOiJkaXIiLCJlbmMiOiJBMTI4Q0JDLUhTMjU2In0..VrTZZcOzyFCPjeO278WvAg.lV--huY2KxUMOd-2v3tpIjCPqwT1S9XO3tZsxrjcaRUZ3JlxqB_XUrdKRikDHHbU8ELvoR6lDJgAlQ4koO7PgaNNqOrNKXBbzql75nDQVTlTFDBOIi-kjVcHZ8Bu_3OIrnOOErbBwWV1h_s2CEWjT8cJFV1ltPo-wxA1RqBABL7OEmleCLqFqYQ9kUEJOF9rzFu9s79UVKCw7JIzZ8wLizsSkK8OPTalgJa4YoqYyonkOwgsswJ1nlIdmkvTflVQKXBbVxsPqZ72jvmnhZJ8wcIuXUoG84GRleTC_JmL8HJI6gnTbyHBIxKUYzKQqQAy1IkG7u3qcqVnk-WkhggtRSgKziogQ9J0nEKEj0wC4abQiFpVtb5XLR1VwLIkpZmBTyfq1k_StFhK1O3j4qjvKLO2o3viUcmUEiOsCKw0-km4ERhEE6yft3RUD5Qx5-1pK79zVdbTN7hg_d-GCUxORV7MiQRbUhPblA1_HUvGhCbN58M-C9tqq9Qv4QX8bnRidH8CwJxLeqeJQNr5iqfQs1goRUgBIGd0G539aW5PlnB_v2X4YUpwHq1i8uwKqrq7uvlcGv9GYSoeBL_UvoLddjJYzIKQjipuojnq3aTId2tl9MK2Zlwu0cdH1Q0uu88N_-8VAYiT3x55fsiwK2Mno_hopJJiL8hPxc-JWArn83BEiLVid7Pj53da8qDYrQ9q.VwOMT8yKYZBcOrP5WZCO9g/__results___files/__results___103_1.png">

네가지 변수가 모두 왜곡되어있으므로, 사분위구간의 범위를 사용해 이상치를 찾아준다

```python
IQR = df.Rainfall.quantile(0.75) - df.Rainfall.quantile(0.25)
Lower_fence = df.Rainfall.quantile(0.25) - (IQR * 3)
Upper_fence = df.Rainfall.quantile(0.75) + (IQR * 3)
print('Rainfall outliers are values < {lowerboundary} or > {upperboundary}'.format(lowerboundary=Lower_fence, upperboundary=Upper_fence))
```
>Rainfall outliers are values < -2.4000000000000004 or > 3.2

Rainfall의 경우 최소치와 최대치 차이가 3.2를 초과하는 경우 이상치로 취급한다.

```python
IQR = df.Evaporation.quantile(0.75) - df.Evaporation.quantile(0.25)
Lower_fence = df.Evaporation.quantile(0.25) - (IQR * 3)
Upper_fence = df.Evaporation.quantile(0.75) + (IQR * 3)
print('Evaporation outliers are values < {lowerboundary} or > {upperboundary}'.format(lowerbou
```
>Evaporation outliers are values < -11.800000000000002 or > 21.800000000000004
Evaporation의 경우에는 21.8을 넘는 경우이다

```python
IQR = df.WindSpeed9am.quantile(0.75) - df.WindSpeed9am.quantile(0.25)
Lower_fence = df.WindSpeed9am.quantile(0.25) - (IQR * 3)
Upper_fence = df.WindSpeed9am.quantile(0.75) + (IQR * 3)
print('WindSpeed9am outliers are values < {lowerboundary} or > {upperboundary}'.format(lowerboundary=Lower_fence, upperboundary=Upper_fence))
```
>WindSpeed9am outliers are values < -29.0 or > 55.0

WindSpeed9am의 경우 55를 초과하는 경우이다.

```python
IQR = df.WindSpeed3pm.quantile(0.75) - df.WindSpeed3pm.quantile(0.25)
Lower_fence = df.WindSpeed3pm.quantile(0.25) - (IQR * 3)
Upper_fence = df.WindSpeed3pm.quantile(0.75) + (IQR * 3)
print('WindSpeed3pm outliers are values < {lowerboundary} or > {upperboundary}'.format(lowerboundary=Lower_fence, upperboundary=Upper_fence))
```
>WindSpeed3pm outliers are values < -20.0 or > 57.0

WindSpeed3Pm은 57을 넘으면 이상치로 취급한다




---
## 8.특징 벡터 대상 변수 선언

---
## 9.데이터를 학습과 테스트 셋으로 분할

---
## 10.특성 처리

---
## 11.특성 스케일링

---
## 12.모델 학습

---
## 13.결과 예측

---
## 14.정확한 점수 예측

---
## 15.혼돈 매트릭스

---
## 16.분류 지표

---
## 17.임계값 조정

---
## 18.ROC-AUC


